# -*- coding: utf-8 -*-
"""ServerGeeksMLProject.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OudNV5_IVwTVggMmV6rTQDouzJgWdHO6

# ML FINAL PROJECT - CSCE 633

### Team: Server Geeks
#### Developers:
  - Kanishk Chhabra
  - Priyal Khapra
  - Dishant Parag Zaveri

#### Project Video

https://youtu.be/3wKZaCrVRzU

#### Project Drive Link

https://drive.google.com/drive/folders/1HpiZfIM8zOEJv_Lla2E6-5l0BILOdevg?usp=sharing

#### DATA FILES USED IN THIS PROJECT

| **Phase**   | **Files**                  |
|-------------|----------------------------|
| **Training**| `img_train.csv`            |
|             | `demo_viome_train.csv`     |
|             | `cgm_train.csv`            |
| **Testing** | `img_test.csv`             |
|             | `demo_viome_test.csv`      |
|             | `cgm_test.csv`             |

| **Phase**   | **Files**                      |
|-------------|--------------------------------|
| **Training**| `label_train.csv`              |
| **Testing** | `label_test_breakfast_only.csv`|

## Importing datasets
"""

import pandas as pd

img_train = pd.read_csv('img_train.csv')
demo_viome_train = pd.read_csv('demo_viome_train.csv')
cmg_train = pd.read_csv('cgm_train.csv')

label_train = pd.read_csv('label_train.csv')

label_test = pd.read_csv('label_test_breakfast_only.csv')

label_train

label_test

"""## preprocessing demo_viome data first"""

demo_viome_train

for i in range(len(demo_viome_train)):
    print(len(demo_viome_train['Viome'][i]))

import numpy as np

type(demo_viome_train['Viome'][0])

array_of_means = []
array_of_max = []
array_of_min = []
for i in range(36):
    list1 = demo_viome_train['Viome'][i].split(',')
    random_sum = 0
    random_max = -1000
    random_min = 1000
    for j in list1:
        temp_num = float(j)
        random_sum += temp_num
        if temp_num > random_max:
            random_max = temp_num
        if temp_num < random_min:
            random_min = temp_num
    print('random mean', random_sum/27)
    print('random max',random_max)
    print('random min',random_min)
    array_of_means.append(random_sum/27)
    array_of_max.append(random_max)
    array_of_min.append(random_min)
    print('----------------------')

np_array_of_means = np.array(array_of_means)
np_array_of_max = np.array(array_of_max)
np_array_of_min = np.array(array_of_min)

# Add aggregate statistics as features
demo_viome_train['Viome_Mean'] = np_array_of_means
demo_viome_train['Viome_Max'] = np_array_of_max
demo_viome_train['Viome_Min'] = np_array_of_min

demo_viome_train.drop(columns=['Viome'], inplace=True)

demo_viome_train.columns

demo_viome_train['Race'].unique()

#one hot encoding of the race column
race_encoded = pd.get_dummies(demo_viome_train['Race'], prefix='Race')

#since there are 3 rows, we can drop one: (0,0) would mean 1 in the third column implictly
race_encoded.drop(columns=['Race_White'], inplace = True)

race_encoded.head()

demo_viome_train = pd.concat([demo_viome_train, race_encoded], axis=1)

demo_viome_train = demo_viome_train.drop(columns=['Race'])

demo_viome_train

"""not scaling the dataframe as of now since there are more columns to be scaled

## Preprocessing Image Data
"""

import numpy as np
import ast

img_train

type(img_train['Image Before Breakfast'][0])

Image_Before_Breakfast_matrix = []
null_breakfast = []

for i in range(len(img_train)):
    string_matrix = img_train['Image Before Breakfast'][i] #the values in the column were in the form of a string, storing them in a variable for preprocessing
    parsed_matrix = ast.literal_eval(string_matrix) #the string matrix is converted into matrix (numerical 3d array type)
    matrix_array = np.array(parsed_matrix) #converted into a numpy library
    print(f"Matrix shape: {matrix_array.shape}, index: {i}")
    print(type(matrix_array))
    if matrix_array.shape == (0,):
        null_breakfast.append(i)    #if the shape of the matrix is 0, means it was a null value since it does not contain any values in them. storing the indices with null value into an array
    else:
        Image_Before_Breakfast_matrix.append(matrix_array)

len(Image_Before_Breakfast_matrix)

len(null_breakfast)

img_train = img_train.drop(null_breakfast)  #dropping the rows containing null values

img_train = img_train.reset_index(drop=True) #resetting the index

img_train

type(Image_Before_Breakfast_matrix[0])

Image_Before_Breakfast_matrix[0]

# import numpy as np
# from tensorflow.keras.applications import ResNet50
# from tensorflow.keras.applications.resnet50 import preprocess_input

import matplotlib.pyplot as plt
plt.imshow(Image_Before_Breakfast_matrix[0])
plt.axis('off')  # Turn off axis labels
plt.show()

import matplotlib.pyplot as plt
plt.imshow(Image_Before_Breakfast_matrix[120])
plt.axis('off')  # Turn off axis labels
plt.show()

import tensorflow as tf
import numpy as np

Image_Before_Breakfast_matrix

Image_Before_Breakfast_matrix[0].shape

Image_Before_Breakfast_matrix[1].shape

for i in range(len(Image_Before_Breakfast_matrix)):
    print(Image_Before_Breakfast_matrix[1].shape)

Image_Before_Breakfast_matrix

# import tensorflow as tf
# from tensorflow.keras.applications import MobileNetV2
# from tensorflow.keras.applications.mobilenet_v2 import preprocess_input
# import numpy as np

# Load MobileNetV2 without the top layer
# model_cnn = MobileNetV2(weights='imagenet', include_top=False, input_shape=(224, 224, 3))

from tensorflow.keras.applications import EfficientNetB0
from tensorflow.keras.applications.efficientnet import preprocess_input
import numpy as np
import tensorflow as tf
model_cnn = EfficientNetB0(weights='imagenet', include_top=False, input_shape=(224, 224, 3))

# from tensorflow.keras.applications import InceptionV3
# model_cnn = InceptionV3(weights='imagenet', include_top=False, input_shape=(224, 224, 3))

def preprocess_images(images):
    """
    Resize and preprocess images for EfficientNetB0.
    Args:
        images (numpy array): Array of images with shape (num_images, 64, 64, 3).
    Returns:
        Preprocessed images with shape (num_images, 224, 224, 3).
    """
    # Resize images to 224x224 since EfficientNetB0 is trained on images of size 224X224. this would help us get better embeddings
    resized_images = tf.image.resize(images, (224, 224)).numpy()

    # Normalize images using EfficientNetB0's preprocess_input
    preprocessed_images = preprocess_input(resized_images)
    return preprocessed_images

def extract_embeddings(model, images):
    """
    Extract embeddings from images using a pretrained model.
    Args:
        model: Pretrained model.
        images: Preprocessed images (num_images, 224, 224, 3).
    Returns:
        Embeddings (num_images, flattened_features).
    """
    # Preprocess images
    preprocessed_images = preprocess_images(images)

    # Extract embeddings
    embeddings = model.predict(preprocessed_images)

    # Flatten the embeddings to (num_images, 62720)
    embeddings = embeddings.reshape(embeddings.shape[0], -1)
    return embeddings

embeddings = extract_embeddings(model_cnn,Image_Before_Breakfast_matrix )

# Check the shape of embeddings
print("Embeddings shape:", embeddings.shape)

embeddings.shape[1]

# just a check, to see if we did get correct embeddings
# we saw many embeddings values as 0, so to verify i ran this loop
for i in range(embeddings.shape[1]):
    if embeddings[0][i] != 0.0:
        print(embeddings[0][i])
        print(i)

from sklearn.decomposition import PCA

def reduce_features_with_pca(embeddings, n_components=50):
    """
    Reduce dimensionality with PCA.
    Args:
        embeddings (numpy array): High-dimensional embeddings (num_samples, num_features).
        n_components (int): Number of principal components to retain.
    Returns:
        Reduced embeddings.
    """
    pca = PCA(n_components=n_components)
    reduced_embeddings = pca.fit_transform(embeddings)
    return reduced_embeddings, pca.explained_variance_ratio_

from sklearn.feature_selection import VarianceThreshold

# Apply Variance Threshold
def reduce_features_with_variance_threshold(reduced_embeddings, threshold=0.01):
    """
    Reduce dimensionality by keeping features with variance above the threshold.
    Args:
        embeddings (numpy array): High-dimensional embeddings (num_samples, num_features).
        threshold (float): Minimum variance required to retain a feature.
    Returns:
        Reduced embeddings.
    """
    selector = VarianceThreshold(threshold=threshold)
    reduced_embeddings = selector.fit_transform(embeddings)
    return reduced_embeddings

# Step 1: Variance Threshold
reduced_embeddings_variance = reduce_features_with_variance_threshold(embeddings, threshold=0.01)

# Step 2: PCA
reduced_embeddings_pca, _ = reduce_features_with_pca(reduced_embeddings_variance, n_components=10)

print("Final reduced embeddings shape:", reduced_embeddings_pca.shape)

reduced_embeddings_pca

img_train

import pandas as pd

print(reduced_embeddings_pca.shape)  # Output: (310, 10)

# Step 1: Converting embeddings to a DataFrame
embeddings_df = pd.DataFrame(
    reduced_embeddings_pca,
    columns=[f"breakfast_embedding_{i+1}" for i in range(reduced_embeddings_pca.shape[1])]
)


img_train = img_train.reset_index(drop=True)  # Reset index if needed

# Step 2: Add embeddings to the original DataFrame
img_train = pd.concat([img_train, embeddings_df], axis=1)


print(img_train.head())

img_train.head(5)

img_train.drop(columns=['Image Before Breakfast'], inplace = True)

img_train

Image_Before_Lunch_matrix = []
null_lunch = []

for i in range(len(img_train)):
    string_matrix = img_train['Image Before Lunch'][i]
    parsed_matrix = ast.literal_eval(string_matrix)
    matrix_array = np.array(parsed_matrix)
    print(f"Matrix shape: {matrix_array.shape}, index: {i}")
    print(type(matrix_array))
    if matrix_array.shape == (0,):
        null_lunch.append(i)
    else:
        Image_Before_Lunch_matrix.append(matrix_array)

len(Image_Before_Lunch_matrix)

len(null_lunch)

img_train = img_train.drop(null_lunch)

img_train = img_train.reset_index(drop=True)

img_train

embeddings = extract_embeddings(model_cnn,Image_Before_Lunch_matrix )


# Check the shape of embeddings
print("Embeddings shape:", embeddings.shape)

for i in range(embeddings.shape[1]):
    if embeddings[0][i] != 0.0:
        print(embeddings[0][i])
        print(i)

# Step 1: Variance Threshold
reduced_embeddings_variance = reduce_features_with_variance_threshold(embeddings, threshold=0.01)

# Step 2: PCA
reduced_embeddings_pca, _ = reduce_features_with_pca(reduced_embeddings_variance, n_components=10)

print("Final reduced embeddings shape:", reduced_embeddings_pca.shape)

import pandas as pd

print(reduced_embeddings_pca.shape)  # Output: (310, 10)

embeddings_df = pd.DataFrame(
    reduced_embeddings_pca,
    columns=[f"lunch_embedding_{i+1}" for i in range(reduced_embeddings_pca.shape[1])]
)

img_train = img_train.reset_index(drop=True)  # Reset index if needed
img_train = pd.concat([img_train, embeddings_df], axis=1)


print(img_train.head())

img_train.head(5)

img_train.drop(columns=['Image Before Lunch'], inplace = True)

"""## preprocessing cmg data"""

cmg_train

cmg_train['CGM Data'][0]

type(cmg_train['Breakfast Time'][0])

breakfast_time_null = []
import pandas as pd

# Check for rows with missing or invalid datetime entries
for i in range(len(cmg_train)):
    value = cmg_train['Breakfast Time'][i]

    # Check if the value is a valid string
    if isinstance(value, str):
        try:
            # Try to convert to datetime
            a = pd.to_datetime(value, errors='raise')  # 'raise' will throw an error if invalid
            # If conversion is successful, format it
            dt = a.strftime('%Y-%m-%d %H:%M:%S')
        except (ValueError, pd.errors.ParserError) as e:
            print(f"Error at index {i}: {value}")
            print(f"Error: {e}")
            breakfast_time_null.append(i)
    else:
        print(f"Non-string value at index {i}: {value}")

breakfast_time_null

lunch_time_null = []
import pandas as pd

# Check for rows with missing or invalid datetime entries
for i in range(len(cmg_train)):
    value = cmg_train['Lunch Time'][i]

    # Check if the value is a valid string
    if isinstance(value, str):
        try:
            # Try to convert to datetime
            a = pd.to_datetime(value, errors='raise')  # 'raise' will throw an error if invalid
            # If conversion is successful, format it
            dt = a.strftime('%Y-%m-%d %H:%M:%S')
        except (ValueError, pd.errors.ParserError) as e:
            print(f"Error at index {i}: {value}")
            print(f"Error: {e}")
            lunch_time_null.append(i)
    else:
        print(f"Non-string value at index {i}: {value}")

union_list = list(set(lunch_time_null) | set(breakfast_time_null))
print(union_list)

cmg_train = cmg_train.drop(union_list)
cmg_train = cmg_train.reset_index(drop=True)
cmg_train

cmg_train['Breakfast_Time'] = pd.to_datetime(cmg_train['Breakfast Time'])
cmg_train['Lunch_Time'] = pd.to_datetime(cmg_train['Lunch Time'])
cmg_train['Hour_Breakfast'] = cmg_train['Breakfast_Time'].dt.hour #extracting hour of breakfast
cmg_train['Day_Of_Week_Breakfast'] = cmg_train['Breakfast_Time'].dt.dayofweek #extracting day of week breakfast
cmg_train['Time_Between_Breakfast_Lunch'] = (cmg_train['Lunch_Time'] - cmg_train['Breakfast_Time']).dt.total_seconds()

cmg_train.drop(columns=['Breakfast Time','Lunch Time','Breakfast_Time','Lunch_Time'],inplace = True)

null_value_in_cgm = 0 #null value check
for i in range(len(cmg_train)):
    if len(cmg_train['CGM Data'][i]) <= 2:
        null_value_in_cgm = i

null_value_in_cgm

cmg_train = cmg_train.drop(null_value_in_cgm) #dropping null value
cmg_train = cmg_train.reset_index(drop=True) #resetting index
cmg_train

cmg_train

type(cmg_train['CGM Data'][0])

import ast

def safe_get_glucose_data(cgm_data):
    try:
        # Convert the string to an actual list of tuples
        if isinstance(cgm_data, str):
            cgm_data = ast.literal_eval(cgm_data)  # Convert string to list of tuples

        # Ensure each entry is a tuple and has at least two elements
        if cgm_data and isinstance(cgm_data, list) and all(isinstance(entry, tuple) and len(entry) >= 2 for entry in cgm_data):
            return sum([entry[1] for entry in cgm_data]) / len(cgm_data)
        else:
            return None
    except Exception as e:
        print(f"Error processing data: {e}")
        return None

# Apply the function to the 'CGM Data' column
Mean_Glucose = cmg_train['CGM Data'].apply(safe_get_glucose_data)
print(Mean_Glucose.head())

Mean_Glucose

np_Mean_Glucose = np.array(Mean_Glucose)

cmg_train['Mean_Glucose'] = np_Mean_Glucose

cmg_train

import pandas as pd
import ast

# Apply the conversion to the 'CGM Data' column
cmg_train['CGM Data'] = cmg_train['CGM Data'].apply(ast.literal_eval)

# Check the first row after conversion
print(cmg_train['CGM Data'][0])

cmg_train['CGM Data'][0][0]

def calculate_rolling_variance(cgm_data, window_size=6):
    # Extract glucose values
    glucose_values = [x[1] for x in cgm_data]

    # Calculate rolling variance
    rolling_var = pd.Series(glucose_values).rolling(window=window_size).var().dropna()

    return rolling_var.tolist()

# Apply rolling variance calculation
window_size = 6  # Half an hour (6 readings for 5-minute intervals)
cmg_train['Rolling_Variances'] = cmg_train['CGM Data'].apply(lambda x: calculate_rolling_variance(x, window_size=window_size))

# Expand rolling variances into separate columns
max_columns = cmg_train['Rolling_Variances'].apply(len).max()  # Find the maximum number of rolling variances
rolling_var_cols = pd.DataFrame(cmg_train['Rolling_Variances'].tolist(),
                                columns=[f'Rolling_Var_Window_{i+1}' for i in range(max_columns)])

# Fill NaN values with 0 in the rolling variance columns
rolling_var_cols = rolling_var_cols.fillna(0)

# Add the new columns to the original DataFrame
cmg_train = pd.concat([cmg_train, rolling_var_cols], axis=1)

# Drop the intermediate Rolling_Variances column for clarity
cmg_train = cmg_train.drop(columns=['Rolling_Variances'])

# Display the updated DataFrame
cmg_train

"""## Merging the datasets"""

cmg_train

img_train

label_train

demo_viome_train

temp_merge = pd.merge(img_train, cmg_train,on=['Subject ID','Day'], how='inner') #inner joining image dataset and time series dataset, since many of its values would be dropped during null value processing.

temp_merge

temp_merge1 = pd.merge(temp_merge, label_train,on=['Subject ID','Day'], how = 'inner') #similarly for label_train and previous merged dataset

temp_merge1

demo_viome_train

merged_df = pd.merge(temp_merge1, demo_viome_train ,on= 'Subject ID') #merging the previous datasets with demo_viome dataset

merged_df

merged_df.dropna(inplace = True) #null value handling

merged_df

merged_df = merged_df.reset_index(drop=True) #resseting index

merged_df.columns

checking_in_rbf = merged_df.drop(columns=['CGM Data','Lunch Calories', 'Lunch Carbs',
                                          'Lunch Protein', 'Lunch Fat', 'Day', 'Breakfast Calories'])

# from sklearn.preprocessing import StandardScaler

# # Use StandardScaler for features
# scaler_X = StandardScaler()
# X_train_scaled = scaler_X.fit_transform(checking_in_rbf)

merged_df['Lunch Calories']

from sklearn.ensemble import RandomForestRegressor
import pandas as pd

# Fit a RandomForest model to identify feature importance
rf = RandomForestRegressor(random_state=42)
rf.fit(checking_in_rbf, merged_df['Lunch Calories'])

# Feature importance
feature_importance = pd.Series(rf.feature_importances_, index=checking_in_rbf.columns)
feature_importance = feature_importance.sort_values(ascending=False)

# Plot feature importance
import matplotlib.pyplot as plt

plt.figure(figsize=(10, 6))
feature_importance.head(20).plot(kind='bar')
plt.title("Top 20 Feature Importance")
plt.show()

# X_scaled = pd.DataFrame(X_train_scaled, columns=checking_in_rbf.columns)

feature_importance[:20]

# Extract the names of the top 20 features
top_20_features = feature_importance.index[:20].tolist()
print(top_20_features)

from sklearn.preprocessing import StandardScaler

# Features and target
X = merged_df[top_20_features]
target_column = merged_df['Lunch Calories']

type(feature_importance)

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from sklearn.model_selection import train_test_split

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, target_column, test_size=0.2, random_state=42)

X_train

from sklearn.preprocessing import StandardScaler

# Use StandardScaler for features
scaler_X = StandardScaler()
X_train_scaled = scaler_X.fit_transform(X_train)
X_test_scaled = scaler_X.transform(X_test)

# Retain y_train and y_test in their original scale
y_train_scaled = y_train  # Keep original target values
y_test_scaled = y_test

pca_on_final = PCA(n_components=2)  # You can change this to any number of components you prefer
X_train_pca = pca_on_final.fit_transform(X_train_scaled)
X_test_pca = pca_on_final.transform(X_test_scaled)

X_train_pca

"""### MODEL ARCHITECTURE

![MLArchitecture.jpg](data:image/jpeg;base64,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)
"""

# Step 1: rmsre value
def modified_mse_for_rmsre(y_true, y_pred):
    epsilon = 1e-8  # Small constant for numerical stability
    y_true = tf.cast(y_true, tf.float32)  # Cast y_true to float32
    relative_error = (y_true - y_pred) / (y_true + epsilon)
    return tf.sqrt(tf.reduce_mean(tf.square(relative_error)))


# Step 2: Build the ANN model
model = keras.Sequential([
    layers.Input(shape=(X_train_pca.shape[1],)),  # Input layer
    layers.Dense(64, activation='relu'),      # Hidden layer with 64 units
    layers.Dense(32, activation='relu'),      # Hidden layer with 32 units
    layers.Dense(16, activation='relu'),      # Hidden layer with 16 units
    layers.Dense(1)                           # Output layer with 1 regression output
])


# Step 3: Compile the model
model.compile(optimizer='adam', loss=modified_mse_for_rmsre)  # Use the custom RMSRE loss function

# Step 4: Train the model
history = model.fit(X_train_pca, y_train_scaled, epochs=100, batch_size=32, validation_split=0.2)

# Step 5: Evaluate the model
test_loss = model.evaluate(X_test_pca, y_test_scaled)
print(f'Test Loss (RMSRE): {test_loss}')

# Step 6: Make predictions
predictions = model.predict(X_test_pca)

predictions

y_test

import keras_tuner as kt
from tensorflow.keras.optimizers import Adam

# Define the model as a hypermodel
def build_model(hp):
    model = keras.Sequential()
    model.add(layers.Input(shape=(X_train_pca.shape[1],)))

    # Increase the number of layers and units
    for i in range(hp.Int("num_layers", 3, 6)):
        model.add(
            layers.Dense(
                units=hp.Int(f"units_{i}", min_value=64, max_value=512, step=64),
                activation="relu",
            )
        )
    model.add(layers.Dense(1))  # Single output for regression

    model.compile(
        optimizer=Adam(learning_rate=hp.Float("learning_rate", 1e-5, 1e-2, sampling="log")),
        loss= modified_mse_for_rmsre,
    )
    return model


# Initialize the tuner
tuner = kt.Hyperband(
    build_model,
    objective="val_loss",  # Minimize validation loss
    max_epochs=50,
    factor=3,
    directory="hyper_tuning",
    project_name="rmsre_ann_tuning",
)

# Perform the search
tuner.search(X_train_pca, y_train_scaled, validation_split=0.2, epochs=50, batch_size=32)

# Get the best hyperparameters and model
best_hps = tuner.get_best_hyperparameters(num_trials=1)[0]
print(f"Best hyperparameters: {best_hps.values}")

# Build and train the best model
best_model = tuner.hypermodel.build(best_hps)
history = best_model.fit(X_train_pca, y_train_scaled, validation_split=0.2, epochs=100, batch_size=32)

# Evaluate on the test set
test_loss = best_model.evaluate(X_test_pca, y_test_scaled)
print(f"Test Loss (RMSRE): {test_loss}")

# Predictions
predictions = best_model.predict(X_test_pca)
print(f'Predictions: {predictions[:5]}')

predictions

"""## testing"""

img_test = pd.read_csv('img_test.csv')
demo_viome_test = pd.read_csv('demo_viome_test.csv')
cgm_test = pd.read_csv('cgm_test.csv')

array_of_means = []
array_of_max = []
array_of_min = []
for i in range(len(demo_viome_test)):
    list1 = demo_viome_test['Viome'][i].split(',')
    random_sum = 0
    random_max = -1000
    random_min = 1000
    for j in list1:
        temp_num = float(j)
        random_sum += temp_num
        if temp_num > random_max:
            random_max = temp_num
        if temp_num < random_min:
            random_min = temp_num
    print('random mean', random_sum/27)
    print('random max',random_max)
    print('random min',random_min)
    array_of_means.append(random_sum/27)
    array_of_max.append(random_max)
    array_of_min.append(random_min)
    print('----------------------')

np_array_of_means = np.array(array_of_means)
np_array_of_max = np.array(array_of_max)
np_array_of_min = np.array(array_of_min)

# Example: Add aggregate statistics as features
demo_viome_test['Viome_Mean'] = np_array_of_means
demo_viome_test['Viome_Max'] = np_array_of_max
demo_viome_test['Viome_Min'] = np_array_of_min

demo_viome_test.drop(columns=['Viome'], inplace=True)

demo_viome_test['Race'].unique()
race_encoded = pd.get_dummies(demo_viome_test['Race'], prefix='Race')
race_encoded.drop(columns=['Race_White'], inplace = True)
demo_viome_test = pd.concat([demo_viome_test, race_encoded], axis=1)
demo_viome_test = demo_viome_test.drop(columns=['Race'])

Image_Before_Breakfast_matrix = []
null_breakfast = []
for i in range(len(img_test)):
    string_matrix = img_test['Image Before Breakfast'][i]
    parsed_matrix = ast.literal_eval(string_matrix)
    matrix_array = np.array(parsed_matrix)
    print(f"Matrix shape: {matrix_array.shape}, index: {i}")
    print(type(matrix_array))
    if matrix_array.shape == (0,):
        null_breakfast.append(i)
    else:
        Image_Before_Breakfast_matrix.append(matrix_array)

img_test = img_test.drop(null_breakfast)

img_test = img_test.reset_index(drop=True)

Image_Before_Breakfast_matrix

for i in range(len(Image_Before_Breakfast_matrix)):
    print(Image_Before_Breakfast_matrix[1].shape)

from tensorflow.keras.applications import EfficientNetB0
from tensorflow.keras.applications.efficientnet import preprocess_input
import numpy as np
import tensorflow as tf

embeddings = extract_embeddings(model_cnn,Image_Before_Breakfast_matrix )

# Check the shape of embeddings
print("Embeddings shape:", embeddings.shape)

for i in range(embeddings.shape[1]):
    if embeddings[0][i] != 0.0:
        print(embeddings[0][i])
        print(i)

# Step 1: Variance Threshold
reduced_embeddings_variance = reduce_features_with_variance_threshold(embeddings, threshold=0.01)

# Step 2: PCA
reduced_embeddings_pca, _ = reduce_features_with_pca(reduced_embeddings_variance, n_components=10)

print("Final reduced embeddings shape:", reduced_embeddings_pca.shape)

embeddings_df = pd.DataFrame(
    reduced_embeddings_pca,
    columns=[f"breakfast_embedding_{i+1}" for i in range(reduced_embeddings_pca.shape[1])]
)

# Step 2: Add embeddings to the original DataFrame
# Ensure the indices match between `img_train` and `embeddings_df`
img_test = img_test.reset_index(drop=True)  # Reset index if needed
img_test = pd.concat([img_test, embeddings_df], axis=1)

# Step 3: Verify the updated DataFrame
print(img_test.head())

img_test.drop(columns=['Image Before Breakfast'], inplace = True)

Image_Before_Lunch_matrix = []
null_lunch = []
for i in range(len(img_test)):
    string_matrix = img_test['Image Before Lunch'][i]
    parsed_matrix = ast.literal_eval(string_matrix)
    matrix_array = np.array(parsed_matrix)
    print(f"Matrix shape: {matrix_array.shape}, index: {i}")
    print(type(matrix_array))
    if matrix_array.shape == (0,):
        null_lunch.append(i)
    else:
        Image_Before_Lunch_matrix.append(matrix_array)
img_test = img_test.drop(null_lunch)
img_test = img_test.reset_index(drop=True)
embeddings = extract_embeddings(model_cnn,Image_Before_Lunch_matrix )

# Check the shape of embeddings
print("Embeddings shape:", embeddings.shape)

# Step 1: Variance Threshold
reduced_embeddings_variance = reduce_features_with_variance_threshold(embeddings, threshold=0.01)

# Step 2: PCA
reduced_embeddings_pca, _ = reduce_features_with_pca(reduced_embeddings_variance, n_components=10)

print("Final reduced embeddings shape:", reduced_embeddings_pca.shape)

import pandas as pd

print(reduced_embeddings_pca.shape)  # Output: (310, 10)

# Step 1: Convert embeddings to a DataFrame
embeddings_df = pd.DataFrame(
    reduced_embeddings_pca,
    columns=[f"lunch_embedding_{i+1}" for i in range(reduced_embeddings_pca.shape[1])]
)

# Step 2: Add embeddings to the original DataFrame
# Ensure the indices match between `img_train` and `embeddings_df`
img_test = img_test.reset_index(drop=True)  # Reset index if needed
img_test = pd.concat([img_test, embeddings_df], axis=1)

# Step 3: Verify the updated DataFrame
print(img_test.head())

img_test.drop(columns=['Image Before Lunch'], inplace = True)

cgm_test

import pandas as pd
import numpy as np

# Example DataFrame
# Initialize a list to store indices of invalid entries
breakfast_time_null = []

# Check for rows with missing or invalid datetime entries
for i in range(len(cgm_test)):
    value = cgm_test['Breakfast Time'][i]

    if isinstance(value, str):  # Check if it's a string
        try:
            # Validate the datetime format
            pd.to_datetime(value, errors='raise')  # Will throw an error if invalid
        except (ValueError, pd.errors.ParserError):
            breakfast_time_null.append(i)  # Log the index
    else:
        breakfast_time_null.append(i)  # Log NaN or non-string values

# Handle invalid values
if breakfast_time_null:
    print(f"Invalid Breakfast Time indices: {breakfast_time_null}")

    # Strategy: Replace with mean time of valid entries
    valid_times = cgm_test.loc[~cgm_test.index.isin(breakfast_time_null), 'Breakfast Time']
    valid_times = pd.to_datetime(valid_times)  # Convert valid entries to datetime

    # Calculate mean time
    mean_time = valid_times.mean()  # Mean of datetime
    mean_time_str = mean_time.strftime('%Y-%m-%d %H:%M:%S')  # Convert back to string

    # Replace invalid entries with mean time
    cgm_test.loc[breakfast_time_null, 'Breakfast Time'] = mean_time_str

cgm_test

breakfast_time_null

cgm_test['Breakfast Time'][52]

import pandas as pd
import numpy as np


# Initialize a list to store indices of invalid entries
lunch_time_null = []

# Check for rows with missing or invalid datetime entries
for i in range(len(cgm_test)):
    value = cgm_test['Lunch Time'][i]

    if isinstance(value, str):  # Check if it's a string
        try:
            # Validate the datetime format
            pd.to_datetime(value, errors='raise')  # Will throw an error if invalid
        except (ValueError, pd.errors.ParserError):
            lunch_time_null.append(i)  # Log the index
    else:
        lunch_time_null.append(i)  # Log NaN or non-string values

# Handle invalid values
if lunch_time_null:
    print(f"Invalid Lunch Time indices: {lunch_time_null}")

    # Strategy: Replace with mean time of valid entries
    valid_times = cgm_test.loc[~cgm_test.index.isin(lunch_time_null), 'Lunch Time']
    valid_times = pd.to_datetime(valid_times)  # Convert valid entries to datetime

    # Calculate mean time
    mean_time = valid_times.mean()  # Mean of datetime
    mean_time_str = mean_time.strftime('%Y-%m-%d %H:%M:%S')  # Convert back to string

    # Replace invalid entries with mean time
    cgm_test.loc[lunch_time_null, 'Lunch Time'] = mean_time_str

cgm_test

lunch_time_null

cgm_test['Lunch Time'][59]

cgm_test['Breakfast_Time'] = pd.to_datetime(cgm_test['Breakfast Time'])
cgm_test['Lunch_Time'] = pd.to_datetime(cgm_test['Lunch Time'])
cgm_test['Hour_Breakfast'] = cgm_test['Breakfast_Time'].dt.hour
cgm_test['Day_Of_Week_Breakfast'] = cgm_test['Breakfast_Time'].dt.dayofweek
cgm_test['Time_Between_Breakfast_Lunch'] = (cgm_test['Lunch_Time'] - cgm_test['Breakfast_Time']).dt.total_seconds()

cgm_test.drop(columns=['Breakfast Time','Lunch Time','Breakfast_Time','Lunch_Time'],inplace = True)

null_value_in_cgm = 0
for i in range(len(cgm_test)):
    if len(cgm_test['CGM Data'][i]) <= 2:
        null_value_in_cgm = i

null_value_in_cgm

import ast

def safe_get_glucose_data(cgm_data):
    try:
        # Convert the string to an actual list of tuples
        if isinstance(cgm_data, str):
            cgm_data = ast.literal_eval(cgm_data)  # Convert string to list of tuples

        # Ensure each entry is a tuple and has at least two elements
        if cgm_data and isinstance(cgm_data, list) and all(isinstance(entry, tuple) and len(entry) >= 2 for entry in cgm_data):
            return sum([entry[1] for entry in cgm_data]) / len(cgm_data)
        else:
            return None
    except Exception as e:
        print(f"Error processing data: {e}")
        return None

# Apply the function to the 'CGM Data' column
Mean_Glucose = cgm_test['CGM Data'].apply(safe_get_glucose_data)
print(Mean_Glucose.head())

cgm_test['CGM Data'] = cgm_test['CGM Data'].apply(ast.literal_eval)

cgm_test

def calculate_rolling_variance(cgm_data, window_size=6):
    # Extract glucose values
    glucose_values = [x[1] for x in cgm_data]

    # Calculate rolling variance
    rolling_var = pd.Series(glucose_values).rolling(window=window_size).var().dropna()

    return rolling_var.tolist()

# Apply rolling variance calculation
window_size = 6  # Half an hour (6 readings for 5-minute intervals)
cgm_test['Rolling_Variances'] = cgm_test['CGM Data'].apply(lambda x: calculate_rolling_variance(x, window_size=window_size))

# Expand rolling variances into separate columns
max_columns = cgm_test['Rolling_Variances'].apply(len).max()  # Find the maximum number of rolling variances
rolling_var_cols = pd.DataFrame(cgm_test['Rolling_Variances'].tolist(),
                                columns=[f'Rolling_Var_Window_{i+1}' for i in range(max_columns)])

# Fill NaN values with 0 in the rolling variance columns
rolling_var_cols = rolling_var_cols.fillna(0)

# Add the new columns to the original DataFrame
cgm_test = pd.concat([cgm_test, rolling_var_cols], axis=1)

# Drop the intermediate Rolling_Variances column for clarity
cgm_test = cgm_test.drop(columns=['Rolling_Variances'])

# Display the updated DataFrame
cgm_test

temp_merge_test = pd.merge(img_test, cgm_test,on=['Subject ID','Day'], how='inner')

temp_merge1_test = pd.merge(temp_merge_test, label_test,on=['Subject ID','Day'], how = 'inner')

merged_df_test = pd.merge(temp_merge1_test, demo_viome_test ,on= 'Subject ID')

merged_df_test.isnull().sum()

merged_df_test

from sklearn.preprocessing import StandardScaler

# Features and target
X_for_testing = merged_df_test[top_20_features]

X_for_testing_scaled = scaler_X.transform(X_for_testing)

X_for_testing_scaled

X_test_pca = pca_on_final.transform(X_for_testing_scaled)

len(X_test_pca)

predictions_test = best_model.predict(X_test_pca)

len(predictions_test)

predictions_test

submission_df = pd.DataFrame({
  'row_id': range(len(predictions_test)),
  'label': predictions_test.flatten()
})

submission_file_path = "submission5.csv"
submission_df.to_csv(submission_file_path, index=False)

print(f"Submission file saved at: {submission_file_path}")

"""Thanks & GIG'EM !!"""